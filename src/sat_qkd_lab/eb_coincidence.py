"""
Entanglement-based QKD (EB-QKD) coincidence Monte Carlo simulator.

This module provides a Monte Carlo simulation of entangled pair generation,
bi-directional loss, background clicks, and coincidence detection for EB-QKD.

Assumptions (explicit):
- Coincidence window: fixed time window (implicit perfect time sync)
- Pair generation: Bernoulli per time bin
- Loss model: independent attenuation on Alice and Bob arms
- Background: Poisson clicks per detector
- No polarization drift or pointing jitter in this minimal version
- Units: coincidence_rate is per sent pair

This is a pedagogical toy model, not a validated prediction tool.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional

import numpy as np

from .detector import DetectorParams, DEFAULT_DETECTOR
from .finite_key import FiniteKeyParams, finite_key_rate_per_pulse
from .helpers import h2


@dataclass(frozen=True)
class EBCoincidenceParams:
    """Parameters for EB-QKD coincidence Monte Carlo simulation."""
    loss_db_alice: float = 0.0
    loss_db_bob: float = 0.0
    flip_prob: float = 0.0
    qber_abort_threshold: float = 0.11
    coincidence_window_ns: float = 1.0  # Coincidence time window (nanoseconds)


def simulate_eb_coincidence_monte_carlo(
    n_pairs: int,
    params: Optional[EBCoincidenceParams] = None,
    detector_alice: Optional[DetectorParams] = None,
    detector_bob: Optional[DetectorParams] = None,
    finite_key: Optional[FiniteKeyParams] = None,
    seed: Optional[int] = None,
) -> Dict[str, Any]:
    """
    Monte Carlo simulation of EB-QKD with coincidence detection.

    This function simulates entangled pair generation, independent loss on
    Alice and Bob arms, background clicks, and coincidence windowing.

    Parameters
    ----------
    n_pairs : int
        Total entangled pairs generated by the source.
    params : EBCoincidenceParams, optional
        EB coincidence parameters (loss, noise, abort threshold).
    detector_alice : DetectorParams, optional
        Alice's detector parameters.
    detector_bob : DetectorParams, optional
        Bob's detector parameters.
    finite_key : FiniteKeyParams, optional
        Finite-key security parameters.
    seed : int, optional
        Random seed for reproducibility.

    Returns
    -------
    dict
        EB coincidence metrics including:
        - coincidence_rate: coincidences per sent pair
        - qber_equivalent: QBER from coincidence mismatches
        - secret_fraction_estimate: toy secret fraction estimate
        - n_secret_est: estimated secret bits
        - aborted: whether protocol aborted due to high QBER
    """
    if n_pairs <= 0:
        raise ValueError("n_pairs must be positive.")

    p = params if params is not None else EBCoincidenceParams()
    det_a = detector_alice if detector_alice is not None else DEFAULT_DETECTOR
    det_b = detector_bob if detector_bob is not None else DEFAULT_DETECTOR
    fk = finite_key if finite_key is not None else FiniteKeyParams()

    rng = np.random.default_rng(seed)

    # Convert loss to transmission probability
    eta_ch_alice = 10 ** (-p.loss_db_alice / 10.0)
    eta_ch_bob = 10 ** (-p.loss_db_bob / 10.0)

    # Effective detection probability per arm
    p_detect_alice = det_a.eta * eta_ch_alice
    p_detect_bob = det_b.eta * eta_ch_bob

    # Background click probability per pair time bin
    p_bg_alice = det_a.p_bg
    p_bg_bob = det_b.p_bg

    # Generate pair arrival and detection events
    # For each pair, simulate whether it's detected on each arm
    pairs_detected_alice = rng.random(n_pairs) < p_detect_alice
    pairs_detected_bob = rng.random(n_pairs) < p_detect_bob

    # Add background clicks (independent Bernoulli per pair time bin)
    background_alice = rng.random(n_pairs) < p_bg_alice
    background_bob = rng.random(n_pairs) < p_bg_bob

    # Total clicks = signal + background (OR logic: click if either triggers)
    click_alice = pairs_detected_alice | background_alice
    click_bob = pairs_detected_bob | background_bob

    # Coincidences: both sides click in the same time bin
    # (simplification: coincidence window = 1 time bin)
    coincidences = click_alice & click_bob
    n_coincidences = int(np.sum(coincidences))

    # For each coincidence, determine the source
    # Signal coincidence: both from pair detection
    # Mixed coincidence: one signal, one background
    # Background coincidence: both from background
    signal_coincidence = coincidences & pairs_detected_alice & pairs_detected_bob
    n_signal_coincidence = int(np.sum(signal_coincidence))

    # Sifted coincidences: assume BB84-like basis matching (50% sifting)
    n_sifted = int(round(n_coincidences * 0.5))

    # QBER model for EB-QKD:
    # - Signal coincidences: intrinsic error rate = flip_prob
    # - Mixed/background coincidences: random bits, 50% error
    # For simplicity, compute expected QBER from signal/background fractions
    if n_coincidences > 0:
        signal_fraction = n_signal_coincidence / n_coincidences
        background_fraction = 1.0 - signal_fraction
        qber_mean = signal_fraction * p.flip_prob + background_fraction * 0.5
        qber_mean = min(0.5, max(0.0, qber_mean))
    else:
        qber_mean = float("nan")

    # Simulate errors in sifted coincidences
    if n_sifted > 0 and not np.isnan(qber_mean):
        n_errors = int(rng.binomial(n_sifted, qber_mean))
    else:
        n_errors = 0

    # Finite-key analysis
    finite = finite_key_rate_per_pulse(
        n_sent=n_pairs,
        n_sifted=n_sifted,
        n_errors=n_errors,
        params=fk,
        qber_abort_threshold=p.qber_abort_threshold,
    )
    finite_key_info = finite["finite_key"]

    # Secret fraction estimate (toy model)
    if finite_key_info["status"] == "secure" and n_sifted > 0:
        secret_fraction_estimate = finite["ell_bits"] / n_sifted
    else:
        secret_fraction_estimate = 0.0

    # Asymptotic secret fraction (for comparison)
    if not np.isnan(qber_mean) and qber_mean < 0.5:
        # Simplified: 1 - 2*h(Q) for EB-QKD (no error correction term in ideal case)
        # Using conservative BB84-like bound: 1 - f*h(Q) - h(Q)
        f_ec = fk.ec_efficiency
        secret_fraction_asymptotic = max(0.0, 1.0 - f_ec * h2(qber_mean) - h2(qber_mean))
    else:
        secret_fraction_asymptotic = 0.0

    # Coincidence rate: coincidences per sent pair
    coincidence_rate = n_coincidences / n_pairs if n_pairs > 0 else 0.0

    return {
        "n_pairs": int(n_pairs),
        "n_coincidences": int(n_coincidences),
        "n_signal_coincidence": int(n_signal_coincidence),
        "n_sifted": int(n_sifted),
        "n_errors": int(n_errors),
        "coincidence_rate": float(coincidence_rate),
        "qber_mean": float(qber_mean),
        "qber_upper": float(finite["qber_upper"]),
        "secret_fraction_estimate": float(secret_fraction_estimate),
        "secret_fraction_asymptotic": float(secret_fraction_asymptotic),
        "n_secret_est": float(finite["ell_bits"]) if finite_key_info["status"] == "secure" else 0.0,
        "key_rate_per_pair": float(finite["key_rate_per_pulse"]) if finite_key_info["status"] == "secure" else 0.0,
        "aborted": bool(finite["aborted"]),
        "finite_key": finite_key_info,
        "meta": {
            "loss_db_alice": float(p.loss_db_alice),
            "loss_db_bob": float(p.loss_db_bob),
            "loss_db_total": float(p.loss_db_alice + p.loss_db_bob),
            "flip_prob": float(p.flip_prob),
            "qber_abort_threshold": float(p.qber_abort_threshold),
            "coincidence_window_ns": float(p.coincidence_window_ns),
            "eta_alice": float(det_a.eta),
            "eta_bob": float(det_b.eta),
            "p_bg_alice": float(det_a.p_bg),
            "p_bg_bob": float(det_b.p_bg),
            "eps_pe": float(fk.eps_pe),
            "eps_sec": float(fk.eps_sec),
            "eps_cor": float(fk.eps_cor),
            "pe_frac": float(fk.pe_frac),
            "seed": seed,
        },
    }


def sweep_eb_coincidence_loss(
    loss_db_values: np.ndarray,
    n_pairs: int,
    flip_prob: float = 0.0,
    detector_alice: Optional[DetectorParams] = None,
    detector_bob: Optional[DetectorParams] = None,
    finite_key: Optional[FiniteKeyParams] = None,
    seed: int = 0,
) -> list[Dict[str, Any]]:
    """
    Sweep EB coincidence simulation over a range of loss values.

    Loss is applied symmetrically to both Alice and Bob arms.

    Parameters
    ----------
    loss_db_values : np.ndarray
        Array of total loss values (dB) to sweep.
    n_pairs : int
        Number of entangled pairs per loss point.
    flip_prob : float
        Intrinsic bit-flip probability.
    detector_alice : DetectorParams, optional
        Alice's detector parameters.
    detector_bob : DetectorParams, optional
        Bob's detector parameters.
    finite_key : FiniteKeyParams, optional
        Finite-key security parameters.
    seed : int
        Base random seed.

    Returns
    -------
    list
        List of simulation results, one per loss value.
    """
    results = []
    for i, loss_db in enumerate(loss_db_values):
        # Split loss equally between Alice and Bob
        loss_per_arm = float(loss_db) / 2.0
        params = EBCoincidenceParams(
            loss_db_alice=loss_per_arm,
            loss_db_bob=loss_per_arm,
            flip_prob=flip_prob,
        )
        result = simulate_eb_coincidence_monte_carlo(
            n_pairs=n_pairs,
            params=params,
            detector_alice=detector_alice,
            detector_bob=detector_bob,
            finite_key=finite_key,
            seed=seed + i,
        )
        result["loss_db"] = float(loss_db)
        results.append(result)
    return results
